<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Athelas by AthelasCo</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Athelas</h1>
        <p></p>

        <p class="view"><a href="https://github.com/AthelasCo/Athelas">View the Project on GitHub <small>AthelasCo/Athelas</small></a></p>


        <ul>
          <li><a href="https://github.com/AthelasCo/Athelas/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/AthelasCo/Athelas/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/AthelasCo/Athelas">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="a-parallel-random-graph-generation-library" class="anchor" href="#a-parallel-random-graph-generation-library" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A parallel random graph generation library.</h1>

<pre><code>                                        By
                        Karandeep Johar &amp; Eshan Verma  
                  kjohar@andrew.cmu.edu   everma@andrew.cmu.edu
</code></pre>

<h3>
<a id="summary" class="anchor" href="#summary" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SUMMARY:</h3>

<p>We will implement a library to generate parallel large-scale graphs using OpenMP/pThreads exploiting CPU Architecture and using CUDA on GPUS. The aim is to compare implementation complexity, speed and resource efficiency.</p>

<h3>
<a id="background" class="anchor" href="#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BACKGROUND:</h3>

<p>Processing Real World graphs is an active research problem. The real-world complex graphs are typically very large (with millions or more vertices) and their sizes grow over time. Some researchers predict that the size of these graphs will eventually reach 10^15 vertices. Unfortunately, we do not have publicly available real graphs that are large enough to test the functionality and true scalability of the graph applications. Hence, graph generation is an important field of research. There are many implementation and algorithms that exist but a serious drawback of these models is that they are all sequential models and thus, are inadequate in their usage to generate massive graphs with billions of vertices and edges.</p>

<ul>
<li>Stochastic Kronecker Graph (A generalization of RMAT graph generation and ER)</li>
<li>Erdos-Renyi graph</li>
<li>Parallel Barabasi-Albert (PBA) method</li>
<li>CL method (Chung Lu)</li>
</ul>

<p>To concentrate best on our aim of comparison of the implementation libraries, we implemented the SKG algorithm which is a generalization on the ER algorithm. The idea was to best optimize this algorithm over the various libraries to analyze the implementation and speedup.</p>

<p>We used SNAP and PaRMAT libraries for initial benchmarking and as code base. The evaluation of our algorithms and benchmarking was implemented by us. The checker functions to ensure that the properties for RMATs were ported from SNAP. Both these libraries provide different options for generations of graphs (directed vs. undirected, sorted vs. unsorted), we modeled our interface to support the same. To get optimal performance, we tuned our kernels/functions to take such parameters in to account.</p>

<h3>
<a id="the-challenge-and-the-tackle" class="anchor" href="#the-challenge-and-the-tackle" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>THE CHALLENGE AND THE TACKLE</h3>

<p>Our project is different from most other tasks handled in this course. There is no reading of input data, rather a large amount of data is generated. Since each node is operated on independently, there is a large communication overhead to ensure connectivity amongst the nodes. Also, there is an inherent workload imbalance, the implementation had to be tuned to that particular use-cases. Along with that we ensured the following:</p>

<ol>
<li>Reducing communication between different parallel elements</li>
<li>Distributing graph over the cores (load balancing)</li>
<li>Writing efficiently to memory</li>
<li>Compressed representation of the graph</li>
</ol>

<h2>
<a id="approach" class="anchor" href="#approach" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>APPROACH</h2>

<p>There are three parts in the approach we adopted:
(1) A Serial CPU Square Generation
All three implementations share a serial section in which the input matrix of edges to be generated is divided up in squares according to the probability distributions and these squares get a connection degree associated with them. The division can be seen in the figure.</p>

<p><img src="https://github.com/AthelasCo/Athelas/blob/gh-pages/images/SQ.png?raw=true" alt="SQ"></p>

<p>NOTE: In our analysis, we have excluded timing of this section as a fixed overhead.</p>

<p>The next part was implemented differently according to the various optimizations available in the three libraries.</p>

<p>(2.a) PTHREADs based Graph Generation</p>

<p>(2.b) openMP Graph Generation</p>

<p>(2.c) CUDA Graph Generation</p>

<h3>
<a id="results" class="anchor" href="#results" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>RESULTS</h3>

<p><img src="https://github.com/AthelasCo/Athelas/blob/gh-pages/images/fused.png?raw=true" alt="Bug in code">
We can see that the original implementation(in red) had a bug and did not actually get the in-degree  curve that we were looking for in a RMAT graph(our implementation in purple). This was an algorithmic change that was needed to ensure correctness as reported by SNAP. The same is ensured across implementations.</p>

<h3>
<a id="resources" class="anchor" href="#resources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>RESOURCES</h3>

<ul>
<li>We will be using the code present here as our starting point:
<a href="https://github.com/farkhor/PaRMAT">"GitHub - snap-stanford/snap: Stanford Network Analysis ..." 2012. 2 Apr. 2016</a>
</li>
<li>The details of which are present in this paper:
<a href="http://www.cs.ucr.edu/%7Egupta/research/Publications/Comp/wsvr.pdf">Chakrabarti, Deepayan, Yiping Zhan, and Christos Faloutsos. "R-MAT: A Recursive Model for Graph Mining." SDM. Vol. 4. 2004.</a>
Khorasani, Farzad, Rajiv Gupta, and Laxmi N. Bhuyan. "Scalable SIMD-Efficient Graph Processing on GPUs. 
and</li>
<li>SNAP, a library out of STANFORD which is based on OpenMPI and we will be referencing their solution as well:</li>
<li><a href="https://github.com/snap-stanford/snap/blob/master/examples/graphgen/graphgen.cpp">"GitHub - snap-stanford/snap: Stanford Network Analysis ..." 2012. 2 Apr. 2016</a></li>
<li><p><a href="http://snap.stanford.edu/class/cs224w-2012/projects/cs224w-035-final.v01.pdf">SNAP: Stanford Network Analysis Project." 2009. 2 Apr. 2016</a></p></li>
<li><p>Our initial understanding of RMATs was influenced by 
<a href="http://www.cs.cmu.edu/%7Echristos/PUBLICATIONS/siam04.pdf">Chakrabarti, Deepayan, Yiping Zhan, and Christos Faloutsos. "R-MAT: A Recursive Model for Graph Mining." SDM. Vol. 4. 2004.</a></p></li>
<li><p>And we will be referencing the following two papers for implementing a parallel Barabasi-Albert method and the Kronecker Graphs:
-<a href="http://arxiv.org/pdf/1003.3684v1.pdf%20Parallel%20Generation%20of%20Massive%20Scale-Free%20Graphs"> Yoo, Andy, and Keith Henderson. "Parallel generation of massive scale-free graphs." arXiv preprint arXiv:1003.3684 (2010)</a></p></li>
<li><p><a href="http://karras.rutgers.edu/rg.pdf">Nobari, Sadegh, et al. "Fast random graph generation." Proceedings of the 14th international conference on extending database technology. ACM, 2011</a></p></li>
<li><p>The CL Algorithm is from this paper:</p></li>
<li><a href="http://arxiv.org/pdf/1406.1215.pdf">Alam, Maksudul, and Maleq Khan. "Parallel Algorithms for Generating Random Networks with Given Degree Sequences." International Journal of Parallel Programming (2014): 1-19.</a></li>
</ul>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/AthelasCo">AthelasCo</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
